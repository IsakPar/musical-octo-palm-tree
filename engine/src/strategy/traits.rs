//! Strategy trait and common types.

use crate::market::{MarketData, TokenId};

/// Trade signal generated by a strategy
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TradeSignal {
    /// Simple buy order
    Buy {
        token_id: TokenId,
        price: f64,
        size: f64,
        reason: String,
    },

    /// Simple sell order
    Sell {
        token_id: TokenId,
        price: f64,
        size: f64,
        reason: String,
    },

    /// Arbitrage opportunity (buy YES and NO)
    Arbitrage {
        yes_token: TokenId,
        no_token: TokenId,
        yes_price: f64,
        no_price: f64,
        profit_per_share: f64,
        size: f64,
    },
}

impl TradeSignal {
    /// Get the primary token ID for this signal
    #[allow(dead_code)]
    pub fn token_id(&self) -> &TokenId {
        match self {
            TradeSignal::Buy { token_id, .. } => token_id,
            TradeSignal::Sell { token_id, .. } => token_id,
            TradeSignal::Arbitrage { yes_token, .. } => yes_token,
        }
    }

    /// Get the notional value of this trade
    pub fn notional(&self) -> f64 {
        match self {
            TradeSignal::Buy { price, size, .. } => price * size,
            TradeSignal::Sell { price, size, .. } => price * size,
            TradeSignal::Arbitrage {
                yes_price,
                no_price,
                size,
                ..
            } => (yes_price + no_price) * size,
        }
    }

    /// Get a description of this signal
    pub fn description(&self) -> String {
        match self {
            TradeSignal::Buy {
                token_id,
                price,
                size,
                reason,
            } => {
                format!(
                    "BUY {} @ ${:.4} x {:.2} ({})",
                    &token_id[..8.min(token_id.len())],
                    price,
                    size,
                    reason
                )
            }
            TradeSignal::Sell {
                token_id,
                price,
                size,
                reason,
            } => {
                format!(
                    "SELL {} @ ${:.4} x {:.2} ({})",
                    &token_id[..8.min(token_id.len())],
                    price,
                    size,
                    reason
                )
            }
            TradeSignal::Arbitrage {
                yes_price,
                no_price,
                profit_per_share,
                size,
                ..
            } => {
                format!(
                    "ARB YES@${:.4} + NO@${:.4} = ${:.4} profit x {:.2}",
                    yes_price, no_price, profit_per_share, size
                )
            }
        }
    }
}

/// Strategy trait - implement this for each trading strategy
pub trait Strategy: Send + Sync {
    /// Evaluate current market conditions and optionally generate a trade signal
    fn evaluate(&self, market_data: &MarketData) -> Option<TradeSignal>;

    /// Strategy name for logging
    fn name(&self) -> &'static str;

    /// Whether this strategy is currently active
    fn is_active(&self) -> bool {
        true
    }
}
